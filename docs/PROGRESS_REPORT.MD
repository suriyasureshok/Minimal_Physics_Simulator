# MINIMAL PHYSICS ENGINE
## Comprehensive Engineering Progress Report

**Project Status:** Phase 2 Complete  
**Date:** February 11, 2026  
**Focus:** Numerical Integration, Stability Analysis, Performance Engineering

---

# ğŸ“‹ TABLE OF CONTENTS

1. [Project Philosophy & Motivation](#philosophy)
2. [Phase 1: Core Engine Architecture](#phase1)
3. [Module-by-Module Deep Dive](#modules)
4. [Phase 2: Numerical Integrator Analysis](#phase2)
5. [Experimental Methodology](#experiments)
6. [Results & Performance Analysis](#results)
7. [Engineering Lessons Learned](#lessons)
8. [Future Roadmap](#roadmap)

---

<a name="philosophy"></a>
# ğŸ¯ PROJECT PHILOSOPHY & MOTIVATION

## Why Build This From Scratch?

This project is **not** a physics toy or game engine. It is a rigorous study in computational physics and numerical methods.

### Core Questions We're Answering:

1. **What is numerical stability?** Not just "avoiding crashes" â€” but understanding why certain integrators preserve physical invariants while others inject spurious energy into the system.

2. **What is the relationship between local accuracy and global reliability?** High-order methods like RK4 can be locally accurate yet fail catastrophically over long time horizons in conservative systems.

3. **How do we measure performance correctly?** Raw ns/step is meaningless. We need to evaluate **simulated time per real second under stability constraints**.

4. **What is structure preservation?** Symplectic integrators preserve geometric properties of Hamiltonian systems â€” this matters more than truncation error order.

5. **How do design decisions propagate?** Clean abstractions allow us to swap components (integrators, forces) without rewriting the entire system.

### Why No Libraries?

We deliberately avoided:
- âŒ SciPy's ODE solvers (black-box behavior)
- âŒ Physics engines (hidden numerical choices)
- âŒ High-level frameworks (abstraction hides implementation)

Instead, we built:
- âœ… Every integrator from first principles
- âœ… Explicit force models
- âœ… Transparent state management
- âœ… Measurable performance paths

**Result:** Complete transparency. No hidden behaviors. Every numerical artifact is observable and explainable.

---

<a name="phase1"></a>
# ğŸ—ï¸ PHASE 1: DETERMINISTIC CORE ENGINE

## 1.1 Objectives

Build a **minimal, deterministic simulation kernel** for 1D particle dynamics.

### Requirements:
- âœ… Fixed timestep (no adaptive stepping â€” complicates stability analysis)
- âœ… Deterministic execution (same inputs â†’ same outputs, always)
- âœ… Modular architecture (swap integrators/forces without touching core)
- âœ… Zero hidden state or randomness
- âœ… Measurable performance from day one

### Why Deterministic Matters:

Before analyzing integrator stability, we must guarantee:
> **The simulator infrastructure itself introduces no randomness, floating-point nondeterminism, or hidden artifacts.**

If the engine is non-deterministic, we cannot isolate integrator behavior.

---

## 1.2 Mathematical Foundation

We chose the **1D simple harmonic oscillator** as our test system:

$$
m \ddot{x} = -kx
$$

This is converted to a first-order ODE system for numerical integration:

$$
\begin{aligned}
\dot{x} &= v \\
\dot{v} &= -\frac{k}{m}x
\end{aligned}
$$

### Why This System?

| Property | Why It Matters |
|----------|----------------|
| **Exact analytical solution** | $x(t) = A \cos(\omega t)$ where $\omega = \sqrt{k/m}$ â€” allows direct error measurement |
| **Hamiltonian structure** | Energy $E = \frac{1}{2}mv^2 + \frac{1}{2}kx^2$ is conserved â€” any drift reveals integrator failure |
| **Oscillatory** | Exposes stability issues instantly (explicit Euler causes exponential growth) |
| **Linear** | No nonlinear complexity â€” isolates integrator behavior |
| **Well-studied** | Stability boundaries are known theoretically |

**This is the simplest non-trivial testbed for numerical integrators.**

---

<a name="modules"></a>
# ğŸ”§ MODULE-BY-MODULE DEEP DIVE

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   User Code                       â”‚
â”‚           (experiments/stability_table.py)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   Simulator     â”‚  â† Orchestration layer
         â”‚  (core/)        â”‚
         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”˜
              â”‚    â”‚   â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚              â”‚             â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
â”‚ State  â”‚   â”‚ Integratorâ”‚   â”‚  Force  â”‚
â”‚ (core/)â”‚   â”‚(integrators/)â”‚ (forces/)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚   TimeKeeper     â”‚  â† Time management
         â”‚   (core/)        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Module 1: `State1D` (`src/mpe/core/state.py`)

### Purpose:
Immutable container for particle state at a single instant.

### Implementation:
```python
@dataclass
class State1D:
    x: float  # position
    v: float  # velocity
```

### Design Decisions:

**Why a dataclass?**
- Immutable by convention (no methods that mutate)
- Clear structure (position + velocity)
- Lightweight (no overhead)

**Why separate from Simulator?**
- State is **data**, not logic
- Integrators operate on state â†’ return new state
- Functional programming pattern: `State â†’ State`

**Why 1D?**
- Simplifies analysis (no vector math overhead)
- Sufficient for studying integrator stability
- Foundation for future ND expansion

**What it does NOT do:**
- âŒ Validate state (no bounds checking)
- âŒ Compute derivatives
- âŒ Store history

**Coupling:** Zero. Pure data structure.

---

## Module 2: `ForceModel` (Base & Implementations)

### Base Class (`src/mpe/forces/base.py`)

```python
class ForceModel(ABC):
    @abstractmethod
    def compute(self, state: State1D, t: float) -> float:
        """Return scalar force value."""
        pass
```

### Why Abstract Base Class?

- **Polymorphism:** Integrators call `force.compute()` without knowing force type
- **Extensibility:** Add new forces without modifying integrator code
- **Type safety:** ABC enforces interface contract

### Implementation: `SpringForce` (`src/mpe/forces/spring.py`)

```python
class SpringForce(ForceModel):
    def __init__(self, k: float):
        self.k = k
    
    def compute(self, state: State1D, t: float) -> float:
        return -self.k * state.x
```

**Mathematical model:** Hooke's Law $F = -kx$

**Key point:** Force depends only on **state**, not history.

### Other Force Models Implemented:

| Force | Equation | Use Case |
|-------|----------|----------|
| `SpringForce` | $F = -kx$ | Harmonic oscillator (primary testbed) |
| `GravityForce` | $F = -mg$ | Constant acceleration |
| `DampedSpringForce` | $F = -kx - \gamma v$ | Energy dissipation studies |

### Why This Abstraction Matters:

Integrators call:
```python
a = force_model.compute(state, t) / mass
```

They **never need to know** if force is:
- Spring
- Gravity
- Damped
- Nonlinear
- Time-dependent

**Separation of concerns achieved.**

---

## Module 3: `Integrator` (Base & Implementations)

### Base Class (`src/mpe/integrators/base.py`)

```python
class Integrator(ABC):
    @abstractmethod
    def step(self, state: State1D, force_model: ForceModel, 
             mass: float, t: float, dt: float) -> State1D:
        pass
```

### Interface Contract:

**Input:**
- Current state
- Force model (for acceleration computation)
- Mass (for $a = F/m$)
- Current time $t$
- Timestep $\Delta t$

**Output:**
- New state at $t + \Delta t$

**Critical:** Integrators are **stateless**. No internal history. Pure function.

### Implementation 1: Explicit Euler (`src/mpe/integrators/explicit_euler.py`)

```python
def step(self, state, force_model, mass, t, dt):
    F = force_model.compute(state, t)
    a = F / mass
    
    new_x = state.x + dt * state.v
    new_v = state.v + dt * a
    
    return State1D(new_x, new_v)
```

**Update equations:**
$$
\begin{aligned}
x_{n+1} &= x_n + \Delta t \cdot v_n \\
v_{n+1} &= v_n + \Delta t \cdot a_n
\end{aligned}
$$

**Properties:**
- First-order accurate ($O(\Delta t)$ local error)
- **Not symplectic** â€” does not preserve phase space volume
- **Not time-reversible**
- Computationally cheapest: 1 force evaluation

**Stability:** Unstable for oscillators (will be proven experimentally)

---

### Implementation 2: Semi-Implicit Euler (`src/mpe/integrators/semi_implicit_euler.py`)

```python
def step(self, state, force_model, mass, t, dt):
    F = force_model.compute(state, t)
    a = F / mass
    
    new_v = state.v + dt * a       # Update velocity first
    new_x = state.x + dt * new_v   # Use NEW velocity
    
    return State1D(new_x, new_v)
```

**Key difference:** Position update uses **new velocity**, not old.

**Properties:**
- First-order accurate
- **Symplectic** â€” preserves modified Hamiltonian
- Area-preserving in phase space
- Same computational cost as Explicit Euler

**Stability:** Stable for oscillators (energy oscillates but doesn't grow)

---

### Implementation 3: Velocity Verlet (`src/mpe/integrators/verlet.py`)

```python
def step(self, state, force_model, mass, t, dt):
    # Acceleration at current state
    F = force_model.compute(state, t)
    a = F / mass
    
    # Update position with current velocity and half-acceleration
    new_x = state.x + state.v * dt + 0.5 * a * dt**2
    
    # Compute acceleration at new position
    temp_state = State1D(new_x, state.v)
    F_new = force_model.compute(temp_state, t + dt)
    a_new = F_new / mass
    
    # Update velocity using average of old and new accelerations
    new_v = state.v + 0.5 * (a + a_new) * dt
    
    return State1D(new_x, new_v)
```

**Properties:**
- Second-order accurate ($O(\Delta t^2)$ local error)
- **Symplectic**
- **Time-reversible** (symmetric update)
- Requires 2 force evaluations per step

**This is the gold standard for molecular dynamics and orbital mechanics.**

---

### Implementation 4: Runge-Kutta 4 (`src/mpe/integrators/rk4.py`)

Classic fourth-order method with 4 intermediate evaluations.

**Properties:**
- Fourth-order accurate ($O(\Delta t^4)$ local error)
- **Not symplectic**
- 4 force evaluations per step
- Excellent for short-term accuracy

**Limitation:** Over long horizons in conservative systems, systematic drift accumulates despite high local accuracy.

---

## Module 4: `Simulator` (`src/mpe/core/simulator.py`)

### Purpose:
Orchestration layer that runs integration loop.

### Implementation:

```python
class Simulator:
    def __init__(self, integrator, force_model, mass):
        self.integrator = integrator
        self.force_model = force_model
        self.mass = mass
    
    def run(self, initial_state, dt, steps):
        state = initial_state
        timekeeper = TimeKeeper(dt)
        
        positions = np.zeros(steps, dtype=np.float64)
        velocities = np.zeros(steps, dtype=np.float64)
        
        for i in range(steps):
            state = self.integrator.step(
                state, self.force_model, self.mass, 
                timekeeper.t, dt
            )
            timekeeper.advance()
            
            positions[i] = state.x
            velocities[i] = state.v
        
        return positions, velocities
```

### Responsibilities:

1. **Loop management:** Execute `steps` iterations
2. **State propagation:** Pass state through integrator
3. **Time tracking:** Advance timekeeper each step
4. **History recording:** Store trajectory in preallocated arrays

### What it does NOT do:

- âŒ Compute forces (delegated to `ForceModel`)
- âŒ Perform integration (delegated to `Integrator`)
- âŒ Analyze results (delegated to `analysis` module)

**Single Responsibility Principle enforced.**

---

## Module 5: `TimeKeeper` (`src/mpe/core/timekeeper.py`)

```python
class TimeKeeper:
    def __init__(self, dt: float):
        self.dt = dt
        self.t = 0.0
        self.step_count = 0
    
    def advance(self):
        self.t += self.dt
        self.step_count += 1
```

### Why Separate Time Management?

- **Clarity:** Time is explicit, not implicit loop index
- **Floating-point safety:** Avoids `t = i * dt` which accumulates rounding error
- **Extensibility:** Future support for adaptive timestepping requires centralized time logic

---

## Module 6: Analysis Modules (`src/mpe/analysis/`)

### 6.1 Energy Module (`energy.py`)

```python
def oscillator_energy(x, v, m, k):
    kinetic = 0.5 * m * v**2
    potential = 0.5 * k * x**2
    return kinetic + potential

def energy_drift(energy):
    return energy - energy[0]
```

**Purpose:** Compute total mechanical energy and measure drift.

**Why energy?** For Hamiltonian systems, energy should be conserved. Drift indicates integrator failure to preserve structure.

### 6.2 Error Module (`error.py`)

```python
def analytic_solution(t_array, A, omega):
    return A * np.cos(omega * t_array)

def absolute_error(x_numeric, x_analytic):
    return np.abs(x_numeric - x_analytic)

def l2_error(x_numeric, x_analytic):
    return np.sqrt(np.mean((x_numeric - x_analytic)**2))
```

**Purpose:** Compare numerical solution to exact analytical solution.

**L2 error:** Global error metric over entire trajectory.

### 6.3 Stability Module (`stability.py`)

**Core function:**
```python
def is_unstable(positions, velocities, mass, k, 
                amp_threshold=100, energy_threshold=0.1):
    # Check for NaN/Inf
    if np.any(np.isnan(positions)) or np.any(np.isinf(positions)):
        return True
    
    # Check amplitude explosion
    if np.max(np.abs(positions)) > amp_threshold:
        return True
    
    # Check energy drift
    energy = oscillator_energy(positions, velocities, mass, k)
    relative_drift = np.abs(energy - energy[0]) / energy[0]
    
    if np.max(relative_drift) > 0.1:  # 10% drift threshold
        return True
    
    return False
```

**Stability criteria (all must pass):**
1. No NaN or Inf
2. Amplitude bounded ($|x| < 100$ for initial $|x| \approx 1$)
3. **Energy drift < 10%** â† Most stringent criterion

**Why 10%?** Stricter than explosion detection, reveals structural failures even when system doesn't blow up.

**Function to find maximum stable timestep:**
```python
def find_max_stable_dt(simulator_factory, integrator, force_model,
                       mass, k, initial_state, dt_values, steps=50000):
    stability_result = {}
    max_stable_dt = None
    
    for dt in dt_values:
        sim = simulator_factory(integrator, force_model, mass)
        state_copy = State1D(initial_state.x, initial_state.v)
        positions, velocities = sim.run(state_copy, dt, steps)
        
        unstable = is_unstable(positions, velocities, mass, k)
        stability_result[dt] = not unstable
        
        if not unstable:
            max_stable_dt = dt
        else:
            break  # Stop at first failure (larger dt will also fail)
    
    return max_stable_dt, stability_result
```

**Binary search optimization:** Tests in increasing order, stops at first failure.

---

<a name="phase2"></a>
# ğŸ”¬ PHASE 2: NUMERICAL INTEGRATOR ANALYSIS

## 2.1 Research Questions

After building the deterministic core, we asked:

1. **Which integrator preserves energy best?**
2. **Which integrator allows the largest stable timestep?**
3. **How do computational costs compare?**
4. **What is the relationship between FLOPs and effective throughput?**
5. **Does high-order accuracy guarantee long-term reliability?**

These questions cannot be answered theoretically alone â€” we need **empirical measurement**.

---

## 2.2 Stability Definition Evolution

### Initial Definition (Naive):

```
Unstable if:
- NaN present
- Inf present
- |x| > threshold
```

**Problem:** This only detects **explosion**. Many integrators fail structurally without exploding.

### Refined Definition (Energy-Based):

```
Unstable if:
- NaN or Inf present
- |x| > 100 (for initial x â‰ˆ 1)
- Relative energy drift > 10%
```

**Why energy drift?**

For a Hamiltonian system, the exact solution has:
$$
E(t) = \text{constant}
$$

Any violation indicates the integrator is not preserving the geometric structure.

**Why 10%?**
- Stricter than explosion (which might be 100Ã— growth)
- Realistic for scientific applications
- Exposes RK4's systematic drift

**This definition changes everything.** Under explosion-only criteria, RK4 looks stable. Under energy criteria, it fails.

---

## 2.3 Test System Configuration

```python
# Physical parameters
m = 1.0          # mass
k = 10.0         # spring constant
omega = sqrt(k/m) = 3.16  # natural frequency

# Initial conditions
x0 = 1.0         # amplitude
v0 = 0.0         # released from rest

# Test range
dt_values = np.linspace(0.0005, 1.0, 800)  # 800 timesteps tested
simulation_steps = 10000  # per dt test
```

**Total simulation time per test:** $T = 10000 \times \Delta t$

For $\Delta t = 0.1$: $T = 1000$ seconds (simulated)  
For $\Delta t = 0.001$: $T = 10$ seconds (simulated)

---

## 2.4 Integrator Comparison Matrix

| Integrator | Order | Symplectic | Time-Reversible | Force Evals/Step |
|------------|-------|------------|-----------------|------------------|
| Explicit Euler | 1 | âŒ | âŒ | 1 |
| Semi-Implicit Euler | 1 | âœ… | âŒ | 1 |
| Verlet | 2 | âœ… | âœ… | 2 |
| RK4 | 4 | âŒ | âŒ | 4 |

**Key insight:** Symplectic structure matters more than order for conservative systems.

---

<a name="experiments"></a>
# ğŸ§ª EXPERIMENTAL METHODOLOGY

## Module 7: Stability Table Experiment (`src/experiments/stability_table.py`)

### Purpose:
Generate comprehensive performance and stability comparison table.

### Metrics Measured:

#### 1. Max Stable $\Delta t$
**Definition:** Largest timestep satisfying stability criteria over 10,000 steps.

**Why it matters:** Larger stable $\Delta t$ â†’ fewer steps â†’ faster simulation.

#### 2. ns/step (Nanoseconds per Step)
**Measurement methodology:**
```python
def measure_step_performance(integrator, force, mass, 
                              initial_state, dt, num_iterations=10000):
    state = State1D(initial_state.x, initial_state.v)
    
    # Warm-up (avoid cold-start overhead)
    for _ in range(100):
        state = integrator.step(state, force, mass, 0.0, dt)
    
    # Actual timing
    state = State1D(initial_state.x, initial_state.v)
    start = time.perf_counter_ns()  # High-precision timer
    
    for i in range(num_iterations):
        state = integrator.step(state, force, mass, float(i) * dt, dt)
    
    end = time.perf_counter_ns()
    
    return (end - start) / num_iterations
```

**Why warm-up?** Python bytecode compilation, CPU cache effects, branch prediction.

**Why 10,000 iterations?** Amortizes timing overhead, provides statistical significance.

#### 3. FLOPs (Floating-Point Operations per Step)

**Estimation methodology:**

We manually count operations in each integrator:

**Explicit Euler:**
```
F = -k * x           # 1 multiply
a = F / m            # 1 divide
new_x = x + dt * v   # 1 multiply, 1 add
new_v = v + dt * a   # 1 multiply, 1 add
Total: ~6 FLOPs
```

**Verlet:**
```
# First force eval
F = -k * x           # 2 ops
a = F / m
# Position update
new_x = x + v*dt + 0.5*a*dtÂ²  # 5 ops
# Second force eval
F_new = -k * new_x   # 2 ops
a_new = F_new / m
# Velocity update
new_v = v + 0.5*(a+a_new)*dt  # 4 ops
Total: ~13 FLOPs
```

**RK4:** 4 force evaluations + intermediate calculations â‰ˆ 38 FLOPs

**Why estimate?** Hardware-level FLOP counting requires profiling tools. Manual estimation gives order-of-magnitude understanding.

#### 4. Simulated Time per Real Second

**Formula:**
$$
\text{Sim-time/sec} = \frac{\Delta t_{\text{max stable}}}{t_{\text{step}}} = \frac{\Delta t_{\text{max}} \times 10^9}{\text{ns/step}}
$$

**Interpretation:** How many simulated seconds advance per real-world second?

**Example:**
- Verlet: $\Delta t_{\text{max}} = 0.256$, ns/step = 1258
- Sim-time/sec = $0.256 \times 10^9 / 1258 = 203,173$

**Verlet simulates 203,000 seconds per real second under stability constraints.**

---

## Experiment Pipeline

```
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  For each integrator:               â”‚
 â”‚  1. Find max stable dt              â”‚
 â”‚  2. Measure ns/step (warm benchmark)â”‚
 â”‚  3. Estimate FLOPs                  â”‚
 â”‚  4. Calculate sim-time/sec          â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Aggregate into DataFrame           â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â†“
 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 â”‚  Print formatted table with notes   â”‚
 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

<a name="results"></a>
# ğŸ“Š RESULTS & PERFORMANCE ANALYSIS

## Comprehensive Stability & Performance Table

```
==============================================================================
STABILITY AND PERFORMANCE TABLE
==============================================================================
              Max Stable dt  ns/step  FLOPs  Sim-time/sec
Euler              0.000500   602.80      6        829.46
SemiImplicit       0.045534   649.24      6      70133.99
Verlet             0.255691  1258.49     13     203173.24
RK4                     NaN  3417.92     38          0.00
==============================================================================

Notes:
- Max Stable dt: Largest timestep maintaining numerical stability
- ns/step: Nanoseconds per integration step (lower is faster)
- FLOPs: Floating-point operations per step
- Sim-time/sec: Simulated seconds advanced per real-world second
```

---

## Analysis by Integrator

### 1. Explicit Euler â€” âŒ FAILED

**Results:**
- Max stable $\Delta t = 0.0005$ (extremely restrictive)
- ns/step = 603 (fastest per-step)
- Sim-time/sec = 829 (worst throughput)

**Observations:**
- Energy grows exponentially
- Even tiny $\Delta t$ fails 10% energy drift criterion
- Amplitude diverges

**Why?**

Update matrix for harmonic oscillator:
$$
\begin{bmatrix} x_{n+1} \\ v_{n+1} \end{bmatrix} = \begin{bmatrix} 1 & \Delta t \\ -\omega^2 \Delta t & 1 \end{bmatrix} \begin{bmatrix} x_n \\ v_n \end{bmatrix}
$$

Eigenvalue magnitude:
$$
|\lambda| = \sqrt{1 + (\omega \Delta t)^2} > 1
$$

**Amplification factor per step** â†’ exponential growth.

**Verdict:** Unsuitable for oscillatory dynamics.

---

### 2. Semi-Implicit Euler â€” âœ… USABLE

**Results:**
- Max stable $\Delta t = 0.045$ (91Ã— better than explicit)
- ns/step = 649 (same cost as explicit)
- Sim-time/sec = 70,134 (85Ã— better than explicit)

**Observations:**
- Energy oscillates around initial value
- No monotonic growth
- Qualitative dynamics preserved

**Why?**

Symplectic integrators preserve a **modified Hamiltonian** $\tilde{H}$:
$$
\tilde{H} = H + O(\Delta t^2)
$$

Energy is not exact, but **bounded**.

**Phase space trajectory:** Forms closed curves (not spirals).

**Verdict:** Reliable for moderate-accuracy simulations.

---

### 3. Velocity Verlet â€” âœ… GOLD STANDARD

**Results:**
- Max stable $\Delta t = 0.256$ (512Ã— better than explicit!)
- ns/step = 1258 (2Ã— slower than explicit)
- **Sim-time/sec = 203,173 (BEST PERFORMANCE)**

**Observations:**
- Minimal energy drift
- Long-term stability
- Second-order accuracy

**Why dominant?**

1. **Symplectic** â†’ preserves phase space structure
2. **Time-reversible** â†’ $x(t) \rightarrow x(t + \Delta t) \rightarrow x(t)$ exact
3. **Second-order** â†’ error $O(\Delta t^2)$ vs $O(\Delta t)$

**Despite 2Ã— cost per step, allows 5.6Ã— larger $\Delta t$ than semi-implicit.**

Net result: **3Ã— faster simulation throughput.**

**This is why Verlet dominates:**
- Molecular dynamics (LAMMPS, GROMACS)
- Orbital mechanics (n-body simulations)
- Game physics engines

**Verdict:** Industry standard for conservative dynamics.

---

### 4. RK4 â€” âŒ FAILED (Long-Term)

**Results:**
- Max stable $\Delta t = $ **NaN** (fails under 10% energy drift)
- ns/step = 3418 (5.7Ã— slower than explicit)
- Sim-time/sec = 0 (unusable)

**Observations:**
- Extremely accurate **short-term**
- Systematic energy drift over long horizons
- Not explosion â€” just gradual monotonic drift

**Why failure?**

RK4 is **not symplectic**. It preserves local truncation error but not geometric structure.

Over $N$ steps:
$$
E(t_N) = E(0) + N \times O(\Delta t^4)
$$

Even though $O(\Delta t^4)$ is tiny per step, over $N = 10,000$ steps, drift accumulates.

**Key lesson:**
$$
\text{Local accuracy} \neq \text{Global reliability}
$$

**When to use RK4:**
- Short simulations
- Non-conservative systems
- Smooth, non-oscillatory dynamics

**When NOT to use:**
- Long-horizon Hamiltonian systems
- Energy preservation requirements
- Oscillatory dynamics

**Verdict:** Wrong tool for this problem.

---

## Performance Comparison Visualization

```
Simulated Time per Real Second (log scale):

Euler          â– 829
SemiImplicit   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 70,134
Verlet         â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 203,173
RK4            (failed)

Verlet is 245Ã— faster than Euler under stability constraints.
```

---

<a name="lessons"></a>
# ğŸ’¡ ENGINEERING LESSONS LEARNED

## Lesson 1: Stability Definition Determines Results

**Initial definition (explosion-only):**
- RK4 looked "stable"
- Measured max $\Delta t \approx 0.5$

**Refined definition (energy-based):**
- RK4 **fails** under 10% drift
- True stable behavior revealed

**Takeaway:** Measurement definitions critically impact conclusions. Choose metrics that capture system invariants.

---

## Lesson 2: Symplectic Structure > Truncation Order

**Order vs. Structure:**

| Method | Order | Symplectic | Long-term Energy |
|--------|-------|------------|------------------|
| RK4 | 4th | âŒ | Drifts |
| Verlet | 2nd | âœ… | Bounded |

**Verlet (2nd order) outperforms RK4 (4th order) for Hamiltonian systems.**

**Why?** Symplectic integrators preserve geometric structure â€” they evolve on the "correct manifold" even if not on the exact trajectory.

---

## Lesson 3: Performance Must Include Stability Constraints

**Naive comparison:**
```
Explicit Euler: 603 ns/step â†’ "fastest"
```

**Realistic comparison:**
```
Explicit Euler: 829 sim-sec/real-sec â†’ slowest
Verlet: 203,173 sim-sec/real-sec â†’ fastest
```

**Raw ns/step is meaningless if you're forced to use tiny $\Delta t$.**

Effective throughput:
$$
\text{Throughput} = \frac{\Delta t_{\text{stable}}}{t_{\text{step}}}
$$

---

## Lesson 4: FLOPs â‰  Wall-Clock Time

**Expected (naive):**
- RK4 has 6Ã— more FLOPs than Euler
- Should be 6Ã— slower

**Observed:**
- RK4 is 5.7Ã— slower (close, but not exact)

**Why difference?**
- Memory access patterns
- Python object creation overhead
- Branch prediction
- Cache effects

**Takeaway:** FLOPs are a proxy, not absolute predictor.

---

## Lesson 5: Modular Architecture Enables Rapid Experimentation

We tested 4 integrators by:

1. Writing `Integrator` subclass (~20 lines each)
2. Passing to existing `Simulator`
3. Running through existing analysis tools

**Zero changes to:**
- Core simulator
- Force models
- Analysis modules

**Result:** Rapid iteration, no code duplication, no coupling.

**This is the value of clean abstractions.**

---

<a name="roadmap"></a>
# ğŸš€ FUTURE ROADMAP

## Phase 3: Performance Optimization

### Planned Improvements:

1. **Remove Python Object Overhead**
   - Replace `State1D` dataclass with raw NumPy arrays
   - Eliminate per-step object allocation

2. **Struct-of-Arrays (SoA) Memory Layout**
   ```python
   # Current (Array-of-Structs):
   states = [State(x1, v1), State(x2, v2), ...]
   
   # Future (Struct-of-Arrays):
   x = np.array([x1, x2, ...])
   v = np.array([v1, v2, ...])
   ```
   **Benefit:** Vectorization, cache locality

3. **Vectorization**
   - Use NumPy broadcasting for multi-particle systems
   - SIMD exploitation

4. **Multi-Particle Systems**
   - Extend to $N$ particles
   - Pairwise force computation
   - $O(N^2) \rightarrow O(N \log N)$ via spatial partitioning

5. **Cache Analysis**
   - Measure L1/L2/L3 cache hit rates
   - Optimize memory access patterns

6. **GPU Batching**
   - Port to CuPy/JAX
   - Batch thousands of simulations (parameter sweeps)

---

## Phase 4: Advanced Integrators

1. **Adaptive Timestepping**
   - Embedded Runge-Kutta methods (RK45)
   - Error estimation and step size control

2. **Implicit Methods**
   - Backward Euler
   - Crank-Nicolson
   - For stiff systems

3. **Higher-Order Symplectic**
   - 4th-order symplectic Runge-Kutta
   - Yoshida integrators

---

## Phase 5: Complex Systems

1. **Multi-Body Dynamics**
   - Planetary systems
   - Gravitational n-body

2. **Constrained Dynamics**
   - Rigid body constraints
   - Lagrange multipliers

3. **Chaotic Systems**
   - Double pendulum
   - Lyapunov exponent measurement

---

## Phase 6: Validation & Comparison

1. **Validation Against Physics Engines**
   - Compare to Bullet, MuJoCo, PyBullet

2. **Publication-Quality Analysis**
   - LaTeX-formatted report
   - Convergence plots
   - Phase space portraits

---

# ğŸ“ CONCLUSION

## What We Built

A **minimal, transparent, modular physics engine** that:

âœ… Demonstrates numerical integrator behavior from first principles  
âœ… Measures stability using physically meaningful criteria  
âœ… Quantifies performance under realistic constraints  
âœ… Proves symplectic structure dominates truncation order  
âœ… Establishes Verlet as optimal for conservative dynamics  

## What We Learned

- **Stability is structural, not just "no crash"**
- **Energy preservation reveals integrator quality**
- **Modular architecture enables rapid experimentation**
- **Performance = throughput under constraints, not raw speed**
- **Measurement definitions drive conclusions**

## Why This Matters

This is not academic exercise. These principles govern:

- Molecular dynamics simulations (drug discovery)
- Orbital mechanics (spacecraft navigation)
- Climate modeling (long-term energy balance)
- Game physics (stable character movement)

**Understanding these fundamentals makes you a better computational scientist and systems engineer.**

---

## Status Summary

| Phase | Status | Deliverables |
|-------|--------|--------------|
| Phase 1: Core Engine | âœ… Complete | Simulator, State, Force, Integrator base classes |
| Phase 2: Integrator Analysis | âœ… Complete | 4 integrators, stability analysis, performance metrics |
| Phase 3: Optimization | ğŸ”„ Planned | NumPy vectorization, SoA layout |
| Phase 4: Advanced Methods | ğŸ“‹ Future | Adaptive stepping, implicit methods |
| Phase 5: Complex Systems | ğŸ“‹ Future | N-body, constraints, chaos |

---

## Experiments Completed

| Experiment | Purpose | Key Result |
|------------|---------|------------|
| `energy_drift.py` | Measure energy conservation | Verlet maintains energy within 0.1%, Explicit Euler diverges |
| `error_growth.py` | Compare to analytical solution | Verlet has $O(\Delta t^2)$ error, Euler has $O(\Delta t)$ error |
| `oscillator_stability.py` | Determine stability boundaries | Verlet stable up to $\Delta t = 0.256$, Euler up to $0.0005$ |
| `stability_table.py` | Comprehensive performance comparison | Verlet achieves 203,173 simulated-sec/real-sec |

---

**Document Version:** 2.0  
**Last Updated:** February 11, 2026  
**Next Review:** Upon Phase 3 completion

---

*This report tracks engineering progress, architectural decisions, experimental methodology, and lessons learned in building a numerical physics simulation engine from scratch. It serves as both a progress log and a technical reference for future development.*
